---
title: "Training model classifying a cell subtype from scRNA-seq data"
author: "Vy Nguyen"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{3. Training child model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(rmarkdown.html_vignette.check_title = FALSE)
```

## Introduction

Apart from a basic model for a basic independent cell type, our methods also 
serve training of models classifying cell types considered as the children 
of another cell type. In this case, the so-called parent cell type must have 
already its classification model.

Here we consider the model classifying child cell type as child model and of
course, parent model is used for classification of parent cell type.

Child model is used to distinguish a particular child cell type from other 
children cell types of the same parent. Therefore, our methods will examine 
all cells by parent model before training and testing for child model. Only 
cells that are considered as parent cell type will be used to train and 
test the new model.

## Parent model
A first prerequisite of training for a child model is the parent model. 
A parent model is of class SingleCellClassR and must be available in the 
working space, among default pretrained models of the package or among 
trained models in users' database.

In this example, we load B cells classifier in the package default 
models to our working place.
```{r}
library(SingleCellClassR)
```
```{r}
data("default_models")
clf_B <- default_models[['B cells']]
clf_B
```
## Preparing train object and test object
Same as training for basic models, training for a child model also requires 
a train (Seurat) object and a test (Seurat) object. All Seurat objects must 
have a slot in meta data indicating the type of cells. Tag slot indicating 
parent cell type can also be provided. In this case, parent cell type tag 
will further be tested for coherence with the provided parent classifier.
```{r}
library(SingleCellClassR.data)
data("feldman_seurat")
```
```{r}
# view train data
feldman_seurat
```
```{r}
# tag slot indicating parent cell type, B cells
head(Idents(feldman_seurat))
```
```{r}
# tag slot indicating cell subset, plasma cells
head(feldman_seurat[['Plasma_cells']])
```
A second object for testing:
```{r}
data("jerby_seurat")

# view test data
jerby_seurat
```

## Defining set of features

Next, we define a set of features, which will be used in training the child 
classification model. Supposing we are training a model for classifying plasma 
cells, we define the set of features as follows:

```{r}
selected_features_plasma <- c("SDC1", "CD19", "BACH2", "CD74", "CD38", "CD37", 
                              "IL6R", "CD2", "CD40LG", "PTEN", "MCL1", "TCF3", 
                              "MZB1", "BANK1", "CD14", "KLF4")
```

## Train model

Training for a child model needs more parameters than training for a basic one.
Users must indicate the parent classifier. There are three ways to indicate the
parent classifier to the train method:
  
  * Users can use an available model in current working place.
  
  * Users can give name of a model among default pretrained models, 
for example: *parent_cell = 'B cells'*
  
  * Users can give name of a model among models available in users' database 
AND the path to that database, for example: *parent_cell = 'B cells', 
path.to.models = '.'*

Train the child classifier:
```{r}
set.seed(123)
clf_plasma <- train_classifier(train_obj = feldman_seurat, 
features = selected_features_plasma, cell_type = "Plasma cells", 
seurat_tag_slot = 'Plasma_cells', parent_clf = clf_B)
```
If B cells classifier has not been loaded to current working space, 
an equivalent training process should be:
```{r}
set.seed(123)
clf_plasma <- train_classifier(train_obj = feldman_seurat, 
features = selected_features_plasma, cell_type = "Plasma cells", 
seurat_tag_slot = 'Plasma_cells', parent_cell = 'B cells')
```
```{r}
clf_plasma
```
```{r}
clf(clf_plasma)
```

## Test model

Parent classifier must be also indicated in test method.
```{r}
clf_plasma_test <- test_classifier(test_obj = jerby_seurat, 
classifier = clf_plasma, seurat_tag_slot = 'Plasma_cells', parent_clf = clf_B)
```

### Interpreting test model result

Same as testing a basic classification models, testing a child classifier also returns an object, which is a list of: *test_tag*, *pred*, *acc*, *auc*, *overall_roc*
  
The *overall_roc* is a summary of True Positive Rate (sensitivity) and False Positive Rate (1 - specificity) obtained by the trained model according to different thresholds:

```{r}
clf_plasma_test$overall_roc
```

We see that with the same TPR (*= 1.0*), the FPR increases if *p_thres* increases to *0.7*. Therefore, this is the better result as compare to the result produced by *p_thres = 0.5*. We change the prediction probability threshold as:

```{r}
p_thres(clf_plasma) <- 0.7
```

Hence the prediction result was changed as:
```{r}
clf_plasma_test <- test_classifier(test_obj = jerby_seurat, 
classifier = clf_plasma, seurat_tag_slot = 'Plasma_cells', parent_clf = clf_B)
```

Now the specificity increased from *0.963759909399774* to *0.994337485843715* and with the same number of actual plasma cells (*65*), the number of predicted cells decreased from *97* to *70*.

The ROC curve remains the same with the same AUC score:
```{r}
print(clf_plasma_test$auc)
roc_curve <- plot_roc_curve(test_result = clf_plasma_test)
plot(roc_curve)
```

## Save child classification model for further use

In order to save child classifier, parent classifier must have existed in the 
classifier database, either in the package default database or in user-defined 
database.
```{r}
# see list of available model in package
data("default_models")
names(default_models)
```
In our package, default models include already models classifying plasma cells.
Therefore, we will save this model to a new local database specified by the 
*path.to.models* parameter. If you start with a fresh new local database, 
there is no available parent classifier of plasma cells' classifier. Therefore,
we have to save the parent classifier first, e.g. the classifier for B cells.

```{r}
# no copy of pretrained models is performed
save_new_model(new_model = clf_B, path.to.models = getwd(), 
               include.default = FALSE) 
save_new_model(new_model = clf_plasma, path.to.models = getwd(), 
               include.default = FALSE) 
```

## Applying newly trained models for cell classification

When we save the B cells' classifier and the plasma cells' classifier, a local database is newly created. We can use this new database to classify cells in a Seurat or SingleCellExperiment object.

Let's try to classify Jerby-Arnon dataset:
```{r}
classified_jerby <- classify_cells(classify_obj = jerby_seurat, 
                                   cell_types = 'all', path_to_models = getwd())
```

Using the *classify_cells()* function, we have to indicate exactly the repository containing the database that the models has recently been saved to. In the previous section, we saved our new models to the current working directory. 

In the *classified_jerby* object, the classification process added new columns to the cell meta data, including the *predicted_cell_type* and *most_probable_cell_type* columns. Let's take a look at the original plasma cells tag:

```{r}
# get a summary of the plasma cells tag
table(classified_jerby[['Plasma_cells']][,1])
# 1 corresponds to cells positive to B cells and 0 corresponds to cells negative to B cells
```
65 cells (labeled 1) are plasma cells and 7121 cells are not plasma cells.

If we use the full prediction to compare with actual plasma tag, we obtain this result: 
```{r}
# compare the prediction with actual cell tag
table(classified_jerby[['predicted_cell_type']][,1], classified_jerby[['Plasma_cells']][,1])
```

We find that 65 actual plasma cells were assigned as B cells and as plasma cells at the same time. This is a reasonable result because in this example, we consider all plasma cells are B cells.

However, comparing the actual tag with the most probable prediction, we obtain: 
```{r}
# compare the prediction with actual cell tag
table(classified_jerby[['most_probable_cell_type']][,1], classified_jerby[['Plasma_cells']][,1])
```

This is a quite surprise result. Among the 65 actual plasma cells, only 1 was identified but 64 others were identified as B cells. In contradiction, the testing process of *clf_plasma* proved that this model could detect all plasma cells in the same dataset. Why this can happen? This contradictory can be explained.

The *predicted_cell_type* takes all predictions having the probabilities satisfying the corresponding probability thresholds. In this case, SingleCellClassR takes all predicted B cells having probability from 0.5 and all predicted plasma cells having probability from 0.7. Meanwhile, the *most_probable_cell_type* takes only the cell type which gives highest prediction probability. Here, 64 predicted plasma cells were also predicted as B cells. However, they have a higher probability to be B cells than to be plasma cells. Therefore, they were classified as B cells in the *most_probable_cell_type*.

To have all plasma cells specified as plasma cells, we can set the *ignore_ambiguous_result* to TRUE. This option will actually hide all ambiguous prediction in case we have more distinct cell types. In the parent-chid(ren) relationship of cell types, the more specified cell types/phenotypes will be reported. Of course, we don't obtain the *most_probable_cell_type* in cell meta data.

```{r}
classified_jerby <- classify_cells(classify_obj = jerby_seurat, 
                                   cell_types = 'all', path_to_models = getwd(),
                                   ignore_ambiguous_result = TRUE)
table(classified_jerby[['predicted_cell_type']][,1], classified_jerby[['Plasma_cells']][,1])
```

To check the B cell classification with actual B cells, we can do as follows:

```{r}
classified_jerby <- classify_cells(classify_obj = jerby_seurat, 
                                   cell_types = 'all', path_to_models = getwd())
# convert B cells label to binaries to ignore details of other cell types
label_B <- Idents(classified_jerby)
label_B <- unlist(lapply(label_B, function(x) if (x == 'B cells') {1} else 0))

# compare prediction with cell label
table(classified_jerby[['most_probable_cell_type']][,1], label_B)
```

## Session Info

```{r}
sessionInfo()
```